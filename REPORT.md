| Лабораторная работа №2     | 24.Б10                    | Архитектура компьютера |
| :------------------------- | ------------------------- | ---------------------- |
| Построение логических схем | Кашенин Андрей Дмитриевич | 2024                   |

## Инструментарий

- **Icarus Verilog** v12.0
- **Logisim Evolution** v3.9.0

## Вариант

Части на **Verilog** и в **Logisim** корректно обрабатывают частные случаи.  
В Verilog есть проблема, что почему-то на такте неправильно считается алгоритм и ставится единичка
В Logisim реализация готова и корректно функционирует.

# Описание

## Идея

Идея моего алгоритма предельно проста: \
Я хочу на на нулевом такте проверить частные случаи, а так же посчитать экспоненту и знак \
Т.е. после первого спада у меня либо ответ посчитан, либо посчитаны экспонента и знак \
Так же я хочу привести мантиссу к какому-то удобному виду, чтобы просто взять из неё целочисленный корень и получить ответ \
Для этого я, в зависимости чётности/нечётности экспоненты(последней позиции 1) сдвигаю мантиссу(мантисса со старшей единицой на 11 позиции. Денормализованные привожу к нужному формату) на 1 бит влево
Потом, т.к. ответ содержит 11 бит данных, то нужно сдвинуть ещё на 10 бит влево. Итого единица либо на 21, либо на 22 позиции. Это как раз 11 блоков.
Значит просто взяв квадратный корень из этой штуки мы получим мантиссу с единичкой на 11 позиции - то что надо

## Реализация

Я в Logisim написал много разных подсхем. В принципе их названия самодокументирующиеся: \
Dtrigger, T, JK, RS, COMP, IF\_... \
Тут стоит сказать, что я долго мучался с D триггерами, потому что мне где-то хотелось, чтобы они обновлялись на спаде синхронизации, а где-то это приводило к гонке \
Поэтому у меня может быть много реализаций RS или D триггера - они на разные случаи жизни \
Например обычный Dtrigger1 основан на RS и нужен, т.к. у меня в нём не было гонок \
Dtrigger на JK нужен чтобы обновлять на спаде синхронизации(если его поставить во все места, то)

Вывод ответа начинается после втрого спада синхронизации

## Принцип взаимодействия со схемой

Так исторически сложилось, что взаимодействие со схемой может показаться костыльным

### Частный случай

Если ответ можно посчитать сразу же, например +-INF, NAN, Zero, то после второго спада ответ выведется на входовыход и всё

### Остальное

На первом такте ничего не выводится. После второго спада выводится экспонента, знак и первые 10 бит итерации алгоритма как мантисса \
Потом экспонента и знак не меняются \
На 3 спаде выводится новая итерация алгоритма, и уже потом на подъёме синхронизации выводятся следующие итерации

## Подсхемы проекта

Ниже приведён список всех основных подсхем проекта `sqrt2.circ` с местами для описания их логики, назначения и роли в общей схеме.

### DtriggerN

**Назначение:**  
D триггер, хранящий N бит. Реализован на RS триггере во избежание гонок \
Поддерживает Enabled

**Принцип работы:**  
Rs триггер. И Enabled реализован просто как логический & с входом триггера

**Роль в общей схеме:**  
Почти везде в схеме для хранения данных используется именно этот D триггер

---

### D_WithoutEnabled

**Назначение:**  
Как DTrigger1, но без Enabled. Нужен для реализации D триггеров без Enabled

**Принцип работы:**  
Просто стандартный D триггер

---

### DtriggerOnJK

**Назначение:**  
D-триггер, собранный на основе JK-триггера, обновляется по спаду CLK

**Принцип работы:**  
Переход по спаду гарантируется тем, что второй RS триггер в JK обновляется на спаде

**Роль в общей схеме:**  
Он нужен чтобы обновление было строго по спаду синхронизации. В некотором месте схемы(обновление входного Enable) это важно

---

### RS

**Назначение:**  
Просто базовый RS триггер

**Принцип работы:**  
RS триггер на элементах не-и(не вижу смысла описывать его таблицу истинности)

**Роль в общей схеме:**  
Является главным, минимальным компонентов других триггеров

---

### JK

**Назначение:**  
Мне была нужна логика RS триггера, гарантирующая обновление на спаде

**Принцип работы:**  
Ведёт себя как RS триггер, но при 1 1 на входе меняет прошлое запомненное значение на противоположное

**Роль в общей схеме:**  
Используется только в D триггерах, которым нужно гарантировать обновление только по спаду синхронизации

---

### T

**Назначение:**  
Нужен для счётчика тактов

**Принцип работы:**  
Этот триггер - немного костыльный. Для него мне пришлось добавить свои старые триггеры с схему

**Роль в общей схеме:**  
Используется в счётчике

### OLD\_\*

**Назначение:**  
Это мои старые триггеры. Их суть в том, что они обновляются на спаде синхронизации и поддерживают мгновенное обнуление \
Поэтому они мне нужны были для счётчика

**Принцип работы:**  
Самое главное - OLD_RS - он просто регулирует непосредственно выход в зависимости от Enable

**Роль в общей схеме:**  
Используется в счётчике

---

### SUM{N}

**Назначение:**  
Суммирует 2 N-битных числа

**Принцип работы:**  
Просто делю число на 2 и суммирую половинки

**Роль в общей схеме:**  
Нужен в алгоритме

---

### COMP{N}

**Назначение:**  
Сравнивает 2 N битных беззнаковых числа

**Принцип работы:**  
Делит число на 2 части и сравнивает половинки

**Роль в общей схеме:**  
Нужен в PriorityEncoder и для алгоритма

---

### PriorityEncoder{N}

**Назначение:**  
Определение позиции старшей единички во входном N-битном числе

**Принцип работы:**  
Делю число на 2, проверяю есть ли в бОльшей части единичка. Если есть, то ищу в ней. Иначе ищу в мЕньшей части

**Роль в общей схеме:**  
Нужно для денормализованных чисел. Для определения их экспоненты

---

### FORMAT_MANT_AND_EXP

**Назначение:**  
Находит экспоненту ответа и приводит мантиссу к формату, где старшая единичка на 21 или 22 позиции

**Принцип работы:**  
Просто аккуратные ифы. Проверки случаев

**Роль в общей схеме:**  
Подготовка числа, из которого будет извлекаться уже целочисленный корень

---

### CHECK_INCORRECT_INP

**Назначение:**  
Проверка на частные случаи(Zero, +-INF, Nan, Neg != Zero)

**Принцип работы:**  
Просто несколько логических элементов и флаги

**Роль в общей схеме:**  
Определяет, частный ли случай и, если да, говорит это внешней схеме

---

### IF\_...

**Назначение:**  
Просто удобная обёртка над компаратором. Сравнивает 2 числа

**Принцип работы:**  
Запускаю компаратор от входных чисел и вывожу нужный ответ

**Роль в общей схеме:**  
Нужна для упрощения схемы

---

### SHIFT

**Назначение:**  
Сдвигает влево на входное количесто бит

**Принцип работы:**  
Я представляю число как двоичное и в зависимости от того, стоит ли единичка на соответствующем бите, сдвигаю на степень двойки

**Роль в общей схеме:**  
Нужно в алгоритме для приведения денормализованных

---

### INT32_SQRT_ALGO

**Назначение:**  
Считает одну итерацию алгоритма и выводит промежуточный ответ

**Принцип работы:**  
Сама итерация - это просто несколько аккуратных проверок и логических элементов \
Запоминание происходит посредством D триггеров, которые работают на обратной синхронизации

**Роль в общей схеме:**  
Является "сердцем" схемы. Проделывает итерации алгоритма

### Counter

**Назначение:**  
Счётчик тактов

**Принцип работы:**  
Просто несколько последовательно подключённых T триггеров

**Роль в общей схеме:**  
Считает номер текущего такта

## SQRT

1. Входовыходы: \
   Моя схема имеет D триггер, который всегда считает входное значение. Вход Enable обёрнут в D триггер на основе JK. Значит он обновится только на спаде и закроет вход \
   Потом в зависимости от того был ли ответ посчитан на первом спаде или нет, открывается выход
   Если нет, то число нарезается и потом форматируется в специальной части схемы(там слева над схемой, которая детектит резалт)
2. Result
   У меня так устроена схема, что ответ будет посчитан либо на 0 такте, либо на 11. Поэтому я просто открываю на 11 такте Result в единичку и всё
3. Сама итерация алгоритма: \
   Не знаю стоит ли тут что-то описывать. Идейно всё предельно просто: \
   Я передаю текущий такт и аккуратно посчитанный CLK и INP_NUMBER. Он что-то считает и возвращает. Я это первые 10 бит этого "чего-то" как ответ


# Эквивалентность схемы с Verilog
В Verilog я просто в зависимости от того, на подъёме ли я синхронизации, или на спаде. И в зависимости от его номера считаю/не считаю следующую итерацию цикла. \
Соответственно на спаде я считаю итерации только пока счётчик меньше 2(строго меньше, т.к. мне не нужно выводить только на одном спаде). Это типо глобальный счётчик. Для тактов у меня счётчик iter_sqrt_iter_cnt \
Внутри такта он просто делает необходимые присваивания \
Частные случаи всё ещё обрабатываются на нулевом такте. Но их вывод начинается только на втором спаде \ 
Я не знаю как ещё подробнее доказать эквивалентность кода и схем: \
Я просто на нужных спадах\подъёмах синхронизации запускаю шаг алгоритма и в нужных местах вывожу ответ
